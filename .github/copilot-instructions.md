# GitHub Copilot Instructions

## Project Overview
This is a minimal Node.js boilerplate project with Docker support, featuring an Express.js server written in TypeScript.

## Tech Stack
- **Runtime**: Node.js
- **Language**: TypeScript
- **Framework**: Express.js
- **Package Manager**: npm
- **Containerization**: Docker & Docker Compose
- **Development**: ts-node with nodemon for auto-reloading

## Project Structure
- `src/` - TypeScript source code
  - `app.ts` - Express app configuration
  - `index.ts` - Server entry point
- `dist/` - Compiled JavaScript (generated by TypeScript)
- `tests/` - Test files
- `tsconfig.json` - TypeScript configuration
- `Dockerfile` - Production container configuration
- `docker-compose.yml` - Development container setup

## Coding Standards
- Use ES6 module syntax (`import`/`export`)
- Leverage TypeScript's type system - avoid `any` type
- Define interfaces for data structures and API contracts
- Use type annotations for function parameters and return types
- Follow async/await pattern for asynchronous operations
- Keep route handlers in separate files for larger applications
- Use Express middleware for cross-cutting concerns
- Implement proper error handling with try-catch blocks
- Enable strict mode in tsconfig.json

## SOLID Principles
Apply SOLID principles to maintain clean, maintainable code:

### Single Responsibility Principle (SRP)
- Each module/class should have one reason to change
- Separate business logic from route handlers
- Keep controllers focused on HTTP concerns only
- Extract services for business logic

### Open/Closed Principle (OCP)
- Design modules to be open for extension but closed for modification
- Use middleware composition for extending functionality
- Implement plugin patterns where appropriate
- Favor configuration over hard-coded values

### Liskov Substitution Principle (LSP)
- Subtypes must be substitutable for their base types
- Maintain consistent interfaces across implementations
- Avoid breaking contracts in derived classes
- Use abstract base classes or interfaces for polymorphism

### Interface Segregation Principle (ISP)
- Clients shouldn't depend on interfaces they don't use
- Create specific, focused interfaces
- Avoid "fat" service objects with too many methods
- Split large interfaces into smaller, role-specific ones

### Dependency Inversion Principle (DIP)
- Depend on abstractions, not concretions
- Inject dependencies rather than hard-coding them
- Use dependency injection for services and repositories
- Decouple high-level modules from low-level implementation details

## Clean Code Rules

### Naming Conventions
- Use meaningful, descriptive names that reveal intent
- Function names should be verbs (`getUserById`, `calculateTotal`, `validateEmail`)
- Variable and class names should be nouns (`user`, `totalAmount`, `UserService`)
- Avoid abbreviations unless widely understood (`req`, `res` are acceptable)
- Use pronounceable names (avoid `genymdhms` for "generated year month day hour minute second")
- Use searchable names (avoid single-letter variables except in short loops)

### Functions
- Functions should do one thing and do it well
- Keep functions small (ideally 5-15 lines, max 20-30)
- Limit function parameters (0-2 ideal, 3 acceptable, avoid 4+)
- Use descriptive names - the longer the scope, the shorter the name can be
- Avoid side effects - functions should not modify external state unexpectedly
- Prefer pure functions when possible
- Use command-query separation (functions either do something or return something, not both)

### Comments
- Write self-documenting code - good code > comments
- Use comments to explain "why", not "what" or "how"
- Remove commented-out code (use version control instead)
- Keep comments up-to-date with code changes
- Use JSDoc for public APIs and complex functions
- Avoid redundant comments (`// increment i` for `i++`)

### Code Organization
- Follow the Stepdown Rule - code reads like a narrative from top to bottom
- Group related functionality together
- Keep files focused and cohesive (max 200-300 lines)
- Place related constants near their usage or in a dedicated config
- Use consistent formatting and indentation (2 spaces)

### Error Handling
- Use exceptions, not error codes
- Provide context with exceptions (meaningful error messages)
- Don't return null - return empty arrays/objects or throw exceptions
- Don't pass null as function parameters
- Use try-catch blocks appropriately, don't catch and ignore
- Create custom error classes for specific error types

### General Rules
- Don't Repeat Yourself (DRY) - extract duplicate code
- Boy Scout Rule - leave code cleaner than you found it
- Prefer composition over inheritance
- Minimize coupling between modules
- Use configuration files for environment-specific values
- Avoid magic numbers - use named constants
- Keep cyclomatic complexity low (avoid deeply nested conditionals)

## Testing
**ALL code MUST be covered with unit tests.**

### Test Requirements
- Every function, class, and module must have corresponding unit tests
- Tests are located in the `tests/` directory
- Run tests with `npm test`
- Tests must pass before any code changes are committed
- Tests must pass before every deployment

### Test Guidelines
- Write simple, focused unit tests that test one thing
- Use descriptive test names that explain what is being tested
- Follow Arrange-Act-Assert (AAA) pattern
- Mock external dependencies to isolate units under test
- Test both happy paths and edge cases
- Test error handling and validation logic
- Aim for high code coverage (minimum 80%)

### Test Workflow
1. Write tests before or alongside new code (TDD approach recommended)
2. Run tests after every change: `npm test`
3. Fix any failing tests immediately
4. Never skip or disable tests to make code pass
5. Run full test suite before pushing code
6. Automated tests should run in CI/CD pipeline before deployment

## Docker Guidelines
- The app runs on port 3000 inside the container
- Use `docker-compose` for development with hot-reloading
- Production Dockerfile uses multi-stage builds if needed
- Environment variables should be documented

## Code Suggestions
When generating code:
- Prefer ES6+ features where appropriate
- Add JSDoc comments for functions
- Include error handling in route handlers
- Keep functions small and focused
- Follow REST API conventions for endpoints

## Dependencies
- Keep dependencies minimal and up-to-date
- Document the purpose of any new dependencies added
- Use `devDependencies` for development-only packages
